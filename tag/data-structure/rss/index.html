<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Data Structure - Hello Koding - Practical Coding Courses, Tutorials and Examples]]></title><description><![CDATA[Practical coding courses, tutorials and examples series of Data Structure, Algorithm Interview Questions, Spring, Java, JPA/Hibernate and REST API]]></description><link>http://hellokoding.com/</link><generator>Ghost 0.9</generator><lastBuildDate>Thu, 19 Sep 2019 13:35:28 GMT</lastBuildDate><atom:link href="http://hellokoding.com/tag/data-structure/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Data Structures Bootcamp for your next Coding Interview]]></title><description><![CDATA[This online course is designed to help you learn the top Data Structure with tutorials and examples series to prepare for your next coding interview]]></description><link>http://hellokoding.com/data-structure-tutorial-example-series/</link><guid isPermaLink="false">1914ae35-2c52-45f1-a5e9-000d89222c58</guid><category><![CDATA[Data Structure]]></category><category><![CDATA[Courses]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Tue, 19 Feb 2019 02:31:14 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/02/data-structure-course.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/02/data-structure-course.png" alt="Data Structures Bootcamp for your next Coding Interview"><p>This online course is designed to help you learn the top Data Structures with tutorials and examples series to prepare for your next coding interview</p>

<h3 id="datastructure">Data Structure</h3>

<p>Data Structure is a collection of data values, the relationships among them, the functions or operations that can be applied to the data that enables efficient access and modification</p>

<h3 id="prerequisites">Prerequisites</h3>

<p>Your local computer should have installed JDK 8+ or OpenJDK 8+, Maven 3+</p>

<h2 id="curriculum">Curriculum</h2>

<h4 id="arraydatastructure">Array Data Structure</h4>

<ul>
<li><a href="https://hellokoding.com/array-data-structure/">Array Data Structure Tutorial and Example</a></li>
</ul>

<h4 id="linkedlistdatastructure">Linked List Data Structure</h4>

<ul>
<li><a href="https://hellokoding.com/linked-list-data-structure-tutorial-and-example/">Linked List Data Structure Tutorial and Example</a></li>
<li><a href="https://hellokoding.com/doubly-linked-list-data-structure-tutorial-and-example/">Doubly Linked List Data Structure Tutorial and Example</a></li>
</ul>

<h4 id="stackandqueuedatastructure">Stack and Queue Data Structure</h4>

<ul>
<li><a href="https://hellokoding.com/stack-data-structure/">Stack Data Structure</a></li>
<li><a href="https://hellokoding.com/queue-data-structure/">Queue Data Structure</a></li>
<li><a href="https://hellokoding.com/double-ended-queue-data-structure/">Double Ended Queue Data Structure</a></li>
<li><a href="https://hellokoding.com/priority-queue-data-structure/">Priority Queue Data Structure</a></li>
</ul>

<h4 id="graphdatastructure">Graph Data Structure</h4>

<ul>
<li><a href="https://hellokoding.com/graph-data-structure/">Graph Data Structure</a></li>
<li><a href="https://hellokoding.com/breadth-first-search-algorithm-on-graph/">Breadth First Search Example of Graph Traversal</a></li>
<li><a href="https://hellokoding.com/depth-first-search-algorithm-on-graph/">Depth First Search Example of Graph Traversal</a>  </li>
</ul>

<h4 id="treedatastructure">Tree Data Structure</h4>

<ul>
<li><a href="https://hellokoding.com/binary-search-tree-data-structure/">Binary Search Tree Data Structure</a></li>
<li><a href="https://hellokoding.com/tree-traversal-with-depth-first-search/">Depth First Search Example of Tree Traversal</a></li>
<li><a href="https://hellokoding.com/tree-level-traversal-with-breadth-first-search/">Breadth First Search Example of Tree Level Traversal</a></li>
<li><a href="https://hellokoding.com/height-of-a-binary-tree/">Height of a Binary Tree</a></li>
</ul>

<h4 id="heapdatastructure">Heap Data Structure</h4>

<ul>
<li><a href="https://hellokoding.com/heap-data-structure/">Heap Data Structure</a></li>
</ul>

<h4 id="disjointsetsdatastructure">Disjoint Sets Data Structure</h4>

<ul>
<li><a href="https://hellokoding.com/disjoint-sets-data-structure-and-union-find-algorithm/">Disjoint Sets Data Structure and Union Find Algorithm</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Depth First Search Example of Tree Traversal]]></title><description><![CDATA[<p>Tree traversal is a process of visiting each node in a tree exactly once. Unlike linear data structures such as array and linked list which are canonically traversed in linear order, tree may be traversed in depth first or breadth first order</p>

<h3 id="depthfirsttraversal">Depth First Traversal</h3>

<p>There are 3 ways of</p>]]></description><link>http://hellokoding.com/tree-traversal-with-depth-first-search/</link><guid isPermaLink="false">29f05931-234f-4059-94b4-26c59e63c6bc</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Mon, 18 Feb 2019 15:42:46 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-16-at-11-02-11-PM-2-1-1-1.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-16-at-11-02-11-PM-2-1-1-1.png" alt="Depth First Search Example of Tree Traversal"><p>Tree traversal is a process of visiting each node in a tree exactly once. Unlike linear data structures such as array and linked list which are canonically traversed in linear order, tree may be traversed in depth first or breadth first order</p>

<h3 id="depthfirsttraversal">Depth First Traversal</h3>

<p>There are 3 ways of depth first traversal, typically, classified by the orders in which nodes are visited</p>

<ul>
<li>Pre-order, visits the parent node before all traversal to the left and the right subtree</li>
<li>In-order, visits the parent node between traversal to the left and the right subtree</li>
<li>Post-order, visits the parent node after all traversal to the left and the right subtree</li>
</ul>

<p><img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-16-at-11-02-11-PM-2-1-1.png" alt="Depth First Search Example of Tree Traversal"></p>

<p>Depth first traversal orders for the above tree</p>

<ul>
<li>Pre-oder is 7-2-1-3-9</li>
<li>In-order is 1-2-3-7-9</li>
<li>Post-oder is 1-3-2-9-7</li>
</ul>

<h2 id="implementationexamplewithrecursivealgorithm">Implementation example with Recursive algorithm</h2>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/TreeDepthFirstTraversalRecursively.java">
</code></pre>

<h2 id="implementationexamplewithiterativealgorithm">Implementation example with Iterative algorithm</h2>

<p>Approach </p>

<ul>
<li>Using a stack to track which node to visit next</li>
</ul>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/TreeDepthFirstTraversalIterably.java">
</code></pre>

<p><code>BSTByLinkedList</code> is defined in <a href="https://hellokoding.com/binary-search-tree-data-structure/">Binary Search Tree Data Structure</a></p>]]></content:encoded></item><item><title><![CDATA[Disjoint Sets Data Structure and Union Find Algorithm]]></title><description><![CDATA[<h3 id="whataredisjointsets">What are Disjoint Sets?</h3>

<p>Disjoint sets are sets whose intersection is the empty set. For example, {0, 1, 2} and {3} are disjoint sets, while {0, 1, 2} and {2, 3} are not.</p>

<h3 id="problem">Problem</h3>

<p>Given some separated elements grouped in disjoint sets. <code>Find</code> whether 2 elements in the same set</p>]]></description><link>http://hellokoding.com/disjoint-sets-data-structure-and-union-find-algorithm/</link><guid isPermaLink="false">40fec8e1-b050-425a-a8b5-c1a23e213c11</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Sat, 23 Sep 2017 15:33:06 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2017/09/Screen-Shot-2017-09-24-at-11-11-23-AM-1.png" medium="image"/><content:encoded><![CDATA[<h3 id="whataredisjointsets">What are Disjoint Sets?</h3>

<img src="http://hellokoding.com/content/images/2017/09/Screen-Shot-2017-09-24-at-11-11-23-AM-1.png" alt="Disjoint Sets Data Structure and Union Find Algorithm"><p>Disjoint sets are sets whose intersection is the empty set. For example, {0, 1, 2} and {3} are disjoint sets, while {0, 1, 2} and {2, 3} are not.</p>

<h3 id="problem">Problem</h3>

<p>Given some separated elements grouped in disjoint sets. <code>Find</code> whether 2 elements in the same set or not.</p>

<h3 id="approach">Approach</h3>

<ul>
<li><p><strong>How to determine if 2 elements are in the same set?</strong> Check if they have the same root/representative.</p></li>
<li><p><strong>How to determine the root/representative of a set?</strong> Unionizing 2 elements by bigger index or by higher rank.</p></li>
</ul>

<h2 id="implementation">Implementation</h2>

<ul>
<li><code>Find</code> with compress path and <code>Union</code> by bigger index</li>
</ul>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/datastructure/DisjoinSetUnionByBiggestIndex.java">
</code></pre>

<p>Initial state of <code>parents</code> <br>
<img src="http://hellokoding.com/content/images/2017/10/Screen-Shot-2017-09-25-at-9-39-09-PM.png" alt="Disjoint Sets Data Structure and Union Find Algorithm"></p>

<p>Final state of <code>parents</code> after all unionizing <br>
<img src="http://hellokoding.com/content/images/2017/09/Screen-Shot-2017-09-24-at-10-40-12-AM.png" alt="Disjoint Sets Data Structure and Union Find Algorithm"></p>

<ul>
<li><code>Find</code> with compress path and <code>Union</code> by higher rank</li>
</ul>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/datastructure/DisjoinSetUnionByRank.java">
</code></pre>

<p>Initial state of <code>parents</code> <br>
<img src="http://hellokoding.com/content/images/2017/10/Screen-Shot-2017-09-25-at-9-39-09-PM.png" alt="Disjoint Sets Data Structure and Union Find Algorithm"></p>

<p>Final state of <code>parents</code> after all unionizing <br>
<img src="http://hellokoding.com/content/images/2017/09/Screen-Shot-2017-09-24-at-11-11-23-AM.png" alt="Disjoint Sets Data Structure and Union Find Algorithm"></p>]]></content:encoded></item><item><title><![CDATA[Height of a Binary Tree]]></title><description><![CDATA[<p>Height of a Binary Tree is a number of edges between the tree's root and its furthest leaf. For example, the height of the following binary tree is 2</p>

<p><img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-16-at-11-02-11-PM-2-1.png" alt=""></p>

<p>A tree consisting of only a single node has a height of 0</p>

<h3 id="problem">Problem</h3>

<p>Find height or maximum depth of a</p>]]></description><link>http://hellokoding.com/height-of-a-binary-tree/</link><guid isPermaLink="false">cd7e74fc-2f1a-4422-886b-376ea2b9053c</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Mon, 18 Feb 2019 01:21:12 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-16-at-11-02-11-PM-2.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-16-at-11-02-11-PM-2.png" alt="Height of a Binary Tree"><p>Height of a Binary Tree is a number of edges between the tree's root and its furthest leaf. For example, the height of the following binary tree is 2</p>

<p><img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-16-at-11-02-11-PM-2-1.png" alt="Height of a Binary Tree"></p>

<p>A tree consisting of only a single node has a height of 0</p>

<h3 id="problem">Problem</h3>

<p>Find height or maximum depth of a given binary tree</p>

<h3 id="approach">Approach</h3>

<p>Using recursive/top-down algorithm, <code>height(root node) = max (height(left subtree of root node), height(right subtree of root node)) + 1</code> and so on</p>

<h2 id="implementation">Implementation</h2>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/BinaryTreeHeight.java">
</code></pre>

<p><code>BSTByLinkedList</code> is defined in <a href="https://hellokoding.com/binary-search-tree-data-structure/">Binary Search Tree Data Structure</a></p>]]></content:encoded></item><item><title><![CDATA[Binary Search Tree Data Structure Tutorial and Example]]></title><description><![CDATA[<h3 id="treedatastructure">Tree Data Structure</h3>

<p>Tree is a non-linear data structure consisting of a collection of nodes which are organized in hierarchy way</p>

<h3 id="binarytreedatastructure">Binary Tree Data Structure</h3>

<p>Binary Tree is a tree data structure in which each node has at most 2 children (left child and right child)</p>

<p><img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-15-at-12-37-39-AM.png" alt=""></p>

<h3 id="binarysearchtreedatastructure">Binary Search Tree Data</h3>]]></description><link>http://hellokoding.com/binary-search-tree-data-structure/</link><guid isPermaLink="false">3f6ea4f5-3bfe-479d-896e-ce313819c518</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Sat, 16 Feb 2019 15:05:28 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-16-at-11-02-11-PM-1.png" medium="image"/><content:encoded><![CDATA[<h3 id="treedatastructure">Tree Data Structure</h3>

<img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-16-at-11-02-11-PM-1.png" alt="Binary Search Tree Data Structure Tutorial and Example"><p>Tree is a non-linear data structure consisting of a collection of nodes which are organized in hierarchy way</p>

<h3 id="binarytreedatastructure">Binary Tree Data Structure</h3>

<p>Binary Tree is a tree data structure in which each node has at most 2 children (left child and right child)</p>

<p><img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-15-at-12-37-39-AM.png" alt="Binary Search Tree Data Structure Tutorial and Example"></p>

<h3 id="binarysearchtreedatastructure">Binary Search Tree Data Structure</h3>

<p>Binary Search Tree, aka ordered/sorted binary tree, is a binary tree in which all parent node's value are greater than theirs left child's values and less than theirs right child's values</p>

<p><img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-16-at-11-02-11-PM.png" alt="Binary Search Tree Data Structure Tutorial and Example"></p>

<h3 id="basicoperations">Basic operations</h3>

<ul>
<li><code>traversal</code>, visits each node in a tree exactly once</li>
<li><code>insert</code>, adds a new node into a tree</li>
<li><code>delete</code>, removes a node from a tree</li>
</ul>

<h3 id="implementations">Implementations</h3>

<p>You can implement a binary search tree with either a linked list, static array (capacity restricted) or a dynamic array</p>

<h2 id="binarysearchtreeimplementationexamplewithlinkedlist">Binary Search Tree implementation example with Linked List</h2>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/datastructure/BSTByLinkedList.java">
</code></pre>]]></content:encoded></item><item><title><![CDATA[Graph Data Structure Tutorial and Example]]></title><description><![CDATA[<p>Graph is a non-linear data structure consisting of a collection of nodes/vertices and edges <code>G = (V, E)</code></p>

<p>Each edge connects a pair of nodes</p>

<h3 id="typesofgraphs">Types of Graphs</h3>

<ul>
<li><p>Undirected graph
<img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-2-47-54-PM.png" alt=""></p></li>
<li><p>Directed graph
<img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-2-46-47-PM.png" alt=""></p></li>
<li><p>Tree is a connected graph (existing a path between every pair of vertices) with no cycles
<img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-2-48-57-PM.png" alt=""></p></li>
</ul>

<h3 id="basicoperations">Basic operations</h3>]]></description><link>http://hellokoding.com/graph-data-structure/</link><guid isPermaLink="false">ab3345a4-f21c-47f1-9a60-175f7f0a8c0d</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Sun, 17 Feb 2019 06:13:10 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-2-47-54-PM-1.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-2-47-54-PM-1.png" alt="Graph Data Structure Tutorial and Example"><p>Graph is a non-linear data structure consisting of a collection of nodes/vertices and edges <code>G = (V, E)</code></p>

<p>Each edge connects a pair of nodes</p>

<h3 id="typesofgraphs">Types of Graphs</h3>

<ul>
<li><p>Undirected graph
<img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-2-47-54-PM.png" alt="Graph Data Structure Tutorial and Example"></p></li>
<li><p>Directed graph
<img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-2-46-47-PM.png" alt="Graph Data Structure Tutorial and Example"></p></li>
<li><p>Tree is a connected graph (existing a path between every pair of vertices) with no cycles
<img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-2-48-57-PM.png" alt="Graph Data Structure Tutorial and Example"></p></li>
</ul>

<h3 id="basicoperations">Basic operations</h3>

<ul>
<li><code>addEdge</code>, add an edge between two vertices of the graph</li>
</ul>

<h3 id="representations">Representations</h3>

<ul>
<li>Adjacency List, every vertex stores a list of adjacent vertices</li>
<li>Adjacency Matrix, a two dimensional matrix array in which the rows represent source vertices and columns represent destination vertices</li>
</ul>

<h2 id="undirectedgraphimplementationexamplewithadjacencylist">Undirected Graph implementation example with Adjacency List</h2>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/datastructure/UndirectedGraphByAdjacencyList.java">
</code></pre>]]></content:encoded></item><item><title><![CDATA[Priority Queue Data Structure Tutorial and Example]]></title><description><![CDATA[<p>Priority Queue Data Structure is a regular <a href="https://hellokoding.com/queue-data-structure/">Queue Data Structure</a> with additional properties </p>

<ul>
<li>Each element has a priority associated with it</li>
<li>An element with high priority is served before an element with low priority</li>
<li>If two elements have the same priority, they are served according to the order in which</li></ul>]]></description><link>http://hellokoding.com/priority-queue-data-structure/</link><guid isPermaLink="false">aee3ef57-bc0a-464f-b677-ba4e74886a0e</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Fri, 22 Feb 2019 09:25:37 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/02/priority-queue.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/02/priority-queue.png" alt="Priority Queue Data Structure Tutorial and Example"><p>Priority Queue Data Structure is a regular <a href="https://hellokoding.com/queue-data-structure/">Queue Data Structure</a> with additional properties </p>

<ul>
<li>Each element has a priority associated with it</li>
<li>An element with high priority is served before an element with low priority</li>
<li>If two elements have the same priority, they are served according to the order in which they are enqueue</li>
</ul>

<h3 id="basicoperations">Basic operations</h3>

<ul>
<li><code>enqueue(element)</code>, inserts an element into the queue with an associated priority</li>
<li><code>dequeue()</code>, retrieves and removes the highest priority element</li>
<li><code>front()</code> aka <code>peek()</code>, retrieves without removing the highest priority element</li>
</ul>

<h3 id="implementations">Implementations</h3>

<p>You can implement a priority queue with either an array, a linked list or a heap (although priority queues conceptually distinct from heaps)</p>

<h2 id="implementationexamplewithamaxheap">Implementation example with a max heap</h2>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/datastructure/PriorityQueueByHeap.java">
</code></pre>

<p><code>MaxHeapByArray</code> is defined in <a href="https://hellokoding.com/heap-data-structure/">Heap Data Structure</a></p>]]></content:encoded></item><item><title><![CDATA[Queue Data Structure Tutorial and Example]]></title><description><![CDATA[<p>Queue is a linear data structure consisting of a collection of elements in FIFO (First In First Out) order</p>

<h3 id="basicoperations">Basic operations</h3>

<ul>
<li><code>Insert</code> aka <code>Enqueue</code>, adds an item onto the end of the queue</li>
<li><code>Remove</code> aka <code>Dequeue</code>, retrieves and removes the head of the queue</li>
<li><code>Examine</code>, retrieves, but does not remove,</li></ul>]]></description><link>http://hellokoding.com/queue-data-structure/</link><guid isPermaLink="false">452fbe68-d8ba-451e-acf7-dfdf93b313a2</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Sun, 10 Feb 2019 17:23:08 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/02/queue-data-structure.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/02/queue-data-structure.png" alt="Queue Data Structure Tutorial and Example"><p>Queue is a linear data structure consisting of a collection of elements in FIFO (First In First Out) order</p>

<h3 id="basicoperations">Basic operations</h3>

<ul>
<li><code>Insert</code> aka <code>Enqueue</code>, adds an item onto the end of the queue</li>
<li><code>Remove</code> aka <code>Dequeue</code>, retrieves and removes the head of the queue</li>
<li><code>Examine</code>, retrieves, but does not remove, the head of the queue</li>
</ul>

<h3 id="otheroperations">Other operations</h3>

<ul>
<li><code>isEmpty</code> returns true if no more items can be dequeued</li>
<li><code>isFull</code> returns true if no more items can be enqueued</li>
<li><code>size</code> returns the number of items on the queue</li>
</ul>

<h3 id="implementation">Implementation</h3>

<p>You can implement a queue with either a Linked List, a Static Array (capacity restricted) or a Dynamic Array</p>

<h2 id="queueimplementationexamplewithstaticarray">Queue implementation example with Static Array</h2>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/datastructure/QueueByArray.java">
</code></pre>

<h3 id="applications">Applications</h3>

<ul>
<li>Breath First Search uses a queue to track which elements to visit next</li>
</ul>]]></content:encoded></item><item><title><![CDATA[Stack Data Structure Tutorial and Example]]></title><description><![CDATA[<p>In this tutorial, you will learn the basic implementation of <code>Stack</code> with Java. You will also quickly walk through some official supports of Stack in Java such as <code>java.util.Deque</code>, <code>java.util.concurrent.BlockingDeque</code> and <code>java.util.Stack</code></p>

<h3 id="whatisstackdatastructure">What is Stack Data Structure?</h3>

<p>Stack is a linear data structure</p>]]></description><link>http://hellokoding.com/stack-data-structure/</link><guid isPermaLink="false">c7cc3432-134f-4dc3-8e09-9aa5508c7d42</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Sun, 10 Feb 2019 15:32:49 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/02/stack-data-structure.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/02/stack-data-structure.png" alt="Stack Data Structure Tutorial and Example"><p>In this tutorial, you will learn the basic implementation of <code>Stack</code> with Java. You will also quickly walk through some official supports of Stack in Java such as <code>java.util.Deque</code>, <code>java.util.concurrent.BlockingDeque</code> and <code>java.util.Stack</code></p>

<h3 id="whatisstackdatastructure">What is Stack Data Structure?</h3>

<p>Stack is a linear data structure of similar data type items, stores data in LIFO (Last In First Out) order</p>

<h3 id="basicoperations">Basic operations</h3>

<ul>
<li><code>push</code> adds an item onto the stack</li>
<li><code>pop</code> removes last pushed item from the stack</li>
<li><code>peek</code> returns the last item pushed onto the stack</li>
</ul>

<h3 id="otheroperations">Other operations</h3>

<ul>
<li><code>isEmpty</code> returns true if no more items can be popped</li>
<li><code>isFull</code> returns true if no more items can be pushed</li>
<li><code>size</code> returns the number of items on the stack</li>
</ul>

<h3 id="implementation">Implementation</h3>

<p>You can implement a stack with either a <code>linked list</code> or an <code>array</code> (static or dynamic)</p>

<h2 id="stackimplementationexamplewithstaticarray">Stack implementation example with Static Array</h2>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/datastructure/StackByArray.java">
</code></pre>

<h3 id="application">Application</h3>

<ul>
<li>Depth First Search uses a stack to track which elements to visit next</li>
</ul>

<h2 id="stackimplementationsinjava">Stack implementations in Java</h2>

<ul>
<li><code>java.util.Deque</code> (interface), since Java 1.6, unsynchronized / not thread-safe, using in single threaded environment. For example</li>
</ul>

<pre><code class="language-java">Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();  
stack.push(1);  
stack.peek();  
stack.pop();  
</code></pre>

<ul>
<li><code>java.util.concurrent.BlockingDeque</code> (interface), since Java 1.6, synchronized / thread-safe, using in multi threaded environment. For example</li>
</ul>

<pre><code class="language-java">BlockingDeque&lt;Integer&gt; stack = new LinkedBlockingDeque&lt;&gt;();  
stack.push(1);  
stack.peek();  
stack.pop();  
</code></pre>

<ul>
<li><code>java.util.Stack</code> (class), since Java 1.1, extends <code>Vector</code>, synchronized, should not be used due to its negative impact on performance</li>
</ul>]]></content:encoded></item><item><title><![CDATA[Linked List Data Structure Tutorial and Example]]></title><description><![CDATA[<p>Linked List is a linear data structure consisting of a collection of nodes which are stored in separated physical memory locations</p>

<p>Each node comprises two parts, the data and the pointer which is linked to the next node. The next pointer of the tail node is linked to null</p>

<p><img src="http://hellokoding.com/content/images/2019/03/Screenshot-2019-03-18-at-12-02-20-AM.png" alt=""></p>

<h3 id="operationsandtimecomplexity">Operations</h3>]]></description><link>http://hellokoding.com/linked-list-data-structure-tutorial-and-example/</link><guid isPermaLink="false">a6e6737d-aa31-4bc5-a3e6-e224d7ad47b2</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Mon, 18 Mar 2019 15:53:52 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/03/Screenshot-2019-03-18-at-12-02-20-AM-1.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/03/Screenshot-2019-03-18-at-12-02-20-AM-1.png" alt="Linked List Data Structure Tutorial and Example"><p>Linked List is a linear data structure consisting of a collection of nodes which are stored in separated physical memory locations</p>

<p>Each node comprises two parts, the data and the pointer which is linked to the next node. The next pointer of the tail node is linked to null</p>

<p><img src="http://hellokoding.com/content/images/2019/03/Screenshot-2019-03-18-at-12-02-20-AM.png" alt="Linked List Data Structure Tutorial and Example"></p>

<h3 id="operationsandtimecomplexity">Operations and Time complexity</h3>

<ul>
<li>Traversal O(N)</li>
<li>Add First O(1), Add Last O(N)</li>
<li>Remove First O(1), Remove Last O(N)</li>
</ul>

<h2 id="implementationexample">Implementation example</h2>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/datastructure/MyLinkedList.java">
</code></pre>]]></content:encoded></item><item><title><![CDATA[Array Data Structure Tutorial and Example]]></title><description><![CDATA[<p>Array is a linear data structure consisting of a collection of elements which are stored in contiguous physical memory locations and identified by index</p>

<h3 id="onedimensionalarray">One dimensional array</h3>

<p>Given a one-dimensional array A has 4 elements like the below image <br>
<img src="http://hellokoding.com/content/images/2019/03/Screenshot-2019-03-17-at-9-13-28-PM.png" alt=""></p>

<p>Each element in the array can be accessed directly by A[</p>]]></description><link>http://hellokoding.com/array-data-structure/</link><guid isPermaLink="false">160e4982-0195-4209-b88d-6e1efad65f3a</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Sun, 17 Mar 2019 13:18:39 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/03/Screenshot-2019-03-17-at-9-13-28-PM-1.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/03/Screenshot-2019-03-17-at-9-13-28-PM-1.png" alt="Array Data Structure Tutorial and Example"><p>Array is a linear data structure consisting of a collection of elements which are stored in contiguous physical memory locations and identified by index</p>

<h3 id="onedimensionalarray">One dimensional array</h3>

<p>Given a one-dimensional array A has 4 elements like the below image <br>
<img src="http://hellokoding.com/content/images/2019/03/Screenshot-2019-03-17-at-9-13-28-PM.png" alt="Array Data Structure Tutorial and Example"></p>

<p>Each element in the array can be accessed directly by A[0], A[1], A[2] and A[3] with the corresponding value 9, 2, 6 and 8</p>

<h4 id="traversalexample">Traversal Example</h4>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/datastructure/Array1D.java">
</code></pre>

<h2 id="twodimensionalarray">Two dimensional array</h2>

<p>Given a two-dimensional array A has 8 elements like the below image</p>

<p><img src="http://hellokoding.com/content/images/2019/03/Screenshot-2019-03-17-at-9-07-49-PM.png" alt="Array Data Structure Tutorial and Example"></p>

<p>Each element in the array can be accessed directly by A[0][0], A[0][1], A[0][2], A[0][3], A[1][0], A[1][1], A[1][2] and A[1][3] with the corresponding value 9, 2, 6, 8, 5, 7, 1 and 3</p>

<h4 id="traversalexample">Traversal Example</h4>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/datastructure/Array2D.java">
</code></pre>]]></content:encoded></item><item><title><![CDATA[Depth First Search Example of Graph Traversal]]></title><description><![CDATA[<p>Depth First Search (DFS) is an algorithm for traversing or searching a graph. The algorithm starts at an arbitrary node and explores as far as possible along each branch before backtracking</p>

<p><img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-4-16-56-PM.png" alt=""></p>

<p>For the above graph with 0 as the starting vertex, assuming that the left edges are chosen before the</p>]]></description><link>http://hellokoding.com/depth-first-search-algorithm-on-graph/</link><guid isPermaLink="false">2b5565be-44a3-462a-85f9-e5adda6a7428</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Sun, 17 Feb 2019 08:00:29 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-4-16-56-PM-1.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-4-16-56-PM-1.png" alt="Depth First Search Example of Graph Traversal"><p>Depth First Search (DFS) is an algorithm for traversing or searching a graph. The algorithm starts at an arbitrary node and explores as far as possible along each branch before backtracking</p>

<p><img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-4-16-56-PM.png" alt="Depth First Search Example of Graph Traversal"></p>

<p>For the above graph with 0 as the starting vertex, assuming that the left edges are chosen before the right edges, the traversing order will be 0 -> 1 -> 3 -> 2 -> 4</p>

<h2 id="implementationexample">Implementation example</h2>

<p>Approach</p>

<ul>
<li>Using an array to track visited nodes to avoid processing a node more than once (graph may contain cycles)</li>
<li>Using a stack to track which nodes to visit next</li>
</ul>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/DepthFirstSearchOnGraph.java">
</code></pre>

<p><code>UndirectedGraphByAdjacencyList</code> is defined in <a href="https://hellokoding.com/graph-data-structure/">Graph Data Structure</a></p>]]></content:encoded></item><item><title><![CDATA[Breadth First Search Example of Graph Traversal]]></title><description><![CDATA[<p>Breadth First Search (BFS) is an algorithm for traversing and searching a graph/tree layer-wise. It starts at an arbitrary node and explores all of the neighbour nodes before moving to the next depth level</p>

<p><img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-4-16-56-PM-2.png" alt=""></p>

<p>For the above graph with 0 as the starting vertex, the traversing order will be</p>]]></description><link>http://hellokoding.com/breadth-first-search-algorithm-on-graph/</link><guid isPermaLink="false">af0bc019-2342-4441-a8b3-4880436c84b4</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Sun, 17 Feb 2019 07:26:00 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-4-16-56-PM-3.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-4-16-56-PM-3.png" alt="Breadth First Search Example of Graph Traversal"><p>Breadth First Search (BFS) is an algorithm for traversing and searching a graph/tree layer-wise. It starts at an arbitrary node and explores all of the neighbour nodes before moving to the next depth level</p>

<p><img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-17-at-4-16-56-PM-2.png" alt="Breadth First Search Example of Graph Traversal"></p>

<p>For the above graph with 0 as the starting vertex, the traversing order will be 0 -> 1 -> 2 -> 3 -> 4</p>

<h2 id="implementationexample">Implementation example</h2>

<p>Approach</p>

<ul>
<li>Using an array to track visited nodes to avoid processing a node more than once (graph may contain cycles)</li>
<li>Using a queue to track which nodes to visit next</li>
</ul>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/BreadthFirstSearchOnGraph.java">
</code></pre>

<p><code>UndirectedGraphByAdjacencyList</code> is defined in <a href="https://hellokoding.com/graph-data-structure/">Graph Data Structure</a></p>]]></content:encoded></item><item><title><![CDATA[Breadth First Search Example of Tree Level Traversal]]></title><description><![CDATA[<p>Tree traversal is a process of visiting each node in a tree exactly once. Unlike linear data structures such as array and linked list which are canonically traversed in linear order, tree may be traversed in depth first or breadth first order</p>

<h3 id="breadthfirsttraversal">Breadth First Traversal</h3>

<p>Visit each node on a</p>]]></description><link>http://hellokoding.com/tree-level-traversal-with-breadth-first-search/</link><guid isPermaLink="false">cf0f47cb-2767-43c0-bafa-27c25b7ab646</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Thu, 21 Feb 2019 15:42:53 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-16-at-11-02-11-PM-2-2.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-16-at-11-02-11-PM-2-2.png" alt="Breadth First Search Example of Tree Level Traversal"><p>Tree traversal is a process of visiting each node in a tree exactly once. Unlike linear data structures such as array and linked list which are canonically traversed in linear order, tree may be traversed in depth first or breadth first order</p>

<h3 id="breadthfirsttraversal">Breadth First Traversal</h3>

<p>Visit each node on a level before going to a lower level</p>

<p><img src="http://hellokoding.com/content/images/2019/02/Screenshot-2019-02-16-at-11-02-11-PM-2-1-1.png" alt="Breadth First Search Example of Tree Level Traversal"></p>

<p>For the above tree, assuming that the left subtree are chosen before the right subtree, breadth first traversal orders will be 7-2-9-1-3</p>

<h2 id="implementationexamplewithiterativealgorithm">Implementation example with Iterative algorithm</h2>

<p>Approach</p>

<ul>
<li>Using a queue to track which node to visit next</li>
</ul>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/TreeBreadthFirstTraversal.java">
</code></pre>

<p><code>BSTByLinkedList</code> is defined in <a href="https://hellokoding.com/binary-search-tree-data-structure/">Binary Search Tree Data Structure</a></p>]]></content:encoded></item><item><title><![CDATA[Double Ended Queue Data Structure Tutorial and Example]]></title><description><![CDATA[<p>Double Ended Queue aka Deque is a regular <a href="https://hellokoding.com/queue-data-structure/">Queue Data Structure</a> with additional property, elements can be added to or removed from either the front (head) or rear (tail)</p>

<h3 id="basicoperations">Basic operations</h3>

<ul>
<li><code>Insert</code> aka <code>Enqueue</code>, inserts element at rear and front of the queue</li>
<li><code>Remove</code> aka <code>Dequeue</code>, retrieves and removes the</li></ul>]]></description><link>http://hellokoding.com/double-ended-queue-data-structure/</link><guid isPermaLink="false">37ca4fb8-d01d-450e-aaff-2c10fe40783d</guid><category><![CDATA[Data Structure]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Tue, 12 Feb 2019 15:33:50 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/02/deque-data-structure.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/02/deque-data-structure.png" alt="Double Ended Queue Data Structure Tutorial and Example"><p>Double Ended Queue aka Deque is a regular <a href="https://hellokoding.com/queue-data-structure/">Queue Data Structure</a> with additional property, elements can be added to or removed from either the front (head) or rear (tail)</p>

<h3 id="basicoperations">Basic operations</h3>

<ul>
<li><code>Insert</code> aka <code>Enqueue</code>, inserts element at rear and front of the queue</li>
<li><code>Remove</code> aka <code>Dequeue</code>, retrieves and removes the rear and the front of the queue</li>
<li><code>Examine</code>, retrieves, but does not remove, the rear and the front of the queue</li>
</ul>

<h3 id="otheroperations">Other operations</h3>

<ul>
<li><code>isEmpty</code> returns true if no more items can be dequeued</li>
<li><code>isFull</code> returns true if no more items can be enqueued</li>
<li><code>size</code> returns the number of items on the queue</li>
</ul>

<h3 id="implementation">Implementation</h3>

<p>You can implement a queue with either a Linked List, a Static Array (capacity restricted) or a Dynamic Array</p>

<h2 id="dequeueimplementationexamplewithstaticarray">Dequeue implementation example with Static Array</h2>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/datastructure/DequeueByArray.java">
</code></pre>]]></content:encoded></item></channel></rss>