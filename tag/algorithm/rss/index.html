<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Algorithm - Hello Koding - Practical Coding Courses, Tutorials and Examples]]></title><description><![CDATA[Practical coding courses, tutorials and examples series of Data Structure, Algorithm Interview Questions, Spring, Java, JPA/Hibernate and REST API]]></description><link>http://hellokoding.com/</link><generator>Ghost 0.9</generator><lastBuildDate>Thu, 19 Sep 2019 13:35:28 GMT</lastBuildDate><atom:link href="http://hellokoding.com/tag/algorithm/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Algorithms Bootcamp for your next Coding Interview]]></title><description><![CDATA[<p>This online course is designed to help you learn the most commonly asked problems in algorithm interview with tutorials and examples series</p>

<h3 id="algorithm">Algorithm</h3>

<p>Algorithm is a step by step procedure to solve a problem</p>

<h3 id="prerequisites">Prerequisites</h3>

<ul>
<li><p>Your local computer should have installed JDK 8+ or OpenJDK 8+, Maven 3+</p></li>
<li><p>You should</p></li></ul>]]></description><link>http://hellokoding.com/algorithm-course-with-tutorials-and-examples-series/</link><guid isPermaLink="false">451f1b33-bbda-44dd-9cd9-f6db52ba8630</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[Courses]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Sat, 16 Mar 2019 04:44:12 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/03/agorithm-course.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/03/agorithm-course.png" alt="Algorithms Bootcamp for your next Coding Interview"><p>This online course is designed to help you learn the most commonly asked problems in algorithm interview with tutorials and examples series</p>

<h3 id="algorithm">Algorithm</h3>

<p>Algorithm is a step by step procedure to solve a problem</p>

<h3 id="prerequisites">Prerequisites</h3>

<ul>
<li><p>Your local computer should have installed JDK 8+ or OpenJDK 8+, Maven 3+</p></li>
<li><p>You should have a basic knowledge of <a href="https://hellokoding.com/data-structure-tutorial-example-series/">Data Structure</a></p></li>
</ul>

<h2 id="curriculum">Curriculum</h2>

<h4 id="string">String</h4>

<ul>
<li><a href="https://hellokoding.com/check-if-two-strings-are-anagram/">Check if two strings are anagram</a></li>
<li><a href="https://hellokoding.com/reverse-words-in-a-string/">Reverse words in a string</a></li>
<li><a href="https://hellokoding.com/length-of-the-longest-substring-without-repeating-characters/">Longest substring without repeating characters</a></li>
<li><a href="https://hellokoding.com/longest-palindromic-substring/">Longest palindromic substring</a></li>
</ul>

<h4 id="twopointers">Two Pointers</h4>

<ul>
<li><a href="https://hellokoding.com/two-pointers-tutorial-and-example/">2Sum</a></li>
<li><a href="https://hellokoding.com/the-3sum-problem/">3Sum</a></li>
</ul>

<h4 id="slidingwindow">Sliding Window</h4>

<ul>
<li><a href="https://hellokoding.com/window-sliding/">Maximum Subarray</a></li>
<li><a href="https://hellokoding.com/find-subarray-with-given-sum/">Find subarray with given sum</a></li>
<li><a href="https://hellokoding.com/given-two-strings-find-a-minimum-substring/">Given two strings, find a minimum substring</a></li>
</ul>

<h4 id="dynamicprogramming">Dynamic Programming</h4>

<ul>
<li><a href="https://hellokoding.com/dynamic-programming/">Fibonacci Numbers</a></li>
<li><a href="https://hellokoding.com/longest-increasing-subsequence/">Longest Increasing Subsequence</a></li>
<li><a href="https://hellokoding.com/box-stacking-problem/">Box Stacking</a></li>
<li><a href="https://hellokoding.com/count-unique-paths-in-a-grid-maze-matrix/">Unique Paths Without Obstacles</a></li>
<li><a href="https://hellokoding.com/count-unique-paths-in-a-2d-array-grid-maze-matrix-with-obstacles/">Unique Paths With Obstacles</a> </li>
<li><a href="https://hellokoding.com/0-1-knapsack-problem/">0-1 Knapsack</a> </li>
<li><a href="https://hellokoding.com/coin-change-problem/">Coin Change</a>  </li>
<li><a href="https://hellokoding.com/coin-change-problem-find-the-minimum-number-of-coins-of-making-change/">Minimum Coin Change</a>  </li>
</ul>

<h4 id="backtracking">Backtracking</h4>

<ul>
<li><a href="https://hellokoding.com/backtracking/">N Queens</a></li>
<li><a href="https://hellokoding.com/given-a-set-find-all-subsets/">Given a set, find all subsets</a></li>
<li><a href="https://hellokoding.com/given-a-string-find-all-permutations/">Given a string, find all permutations</a></li>
</ul>

<h4 id="divideandconquer">Divide and Conquer</h4>

<ul>
<li><a href="https://hellokoding.com/divide-and-conquer/">Merge Sort</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Minimum Window Substring]]></title><description><![CDATA[<h3 id="problem">Problem</h3>

<ul>
<li>Given two strings <code>s</code> of length m and <code>t</code> of length n</li>
<li>Find a minimum substring in <code>s</code> which contains all characters in <code>t</code></li>
</ul>

<h3 id="example">Example</h3>

<ul>
<li>Input: given two strings <code>aaaaaaaaaaaabbbbbcdd</code> and <code>abcdd</code></li>
<li>Expected output: <code>abbbbbcdd</code></li>
</ul>

<h3 id="approachslidingwindow">Approach: Sliding Window</h3>

<p>Iterating over <code>s</code> window by window with two index pointers <code>i</code></p>]]></description><link>http://hellokoding.com/given-two-strings-find-a-minimum-substring/</link><guid isPermaLink="false">514d2867-4028-4cee-be3c-059294c6ad03</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Tue, 12 Mar 2019 13:19:36 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/SlidingWindow_MininumWindowSubstring.png" medium="image"/><content:encoded><![CDATA[<h3 id="problem">Problem</h3>

<ul>
<li>Given two strings <code>s</code> of length m and <code>t</code> of length n</li>
<li>Find a minimum substring in <code>s</code> which contains all characters in <code>t</code></li>
</ul>

<h3 id="example">Example</h3>

<ul>
<li>Input: given two strings <code>aaaaaaaaaaaabbbbbcdd</code> and <code>abcdd</code></li>
<li>Expected output: <code>abbbbbcdd</code></li>
</ul>

<h3 id="approachslidingwindow">Approach: Sliding Window</h3>

<img src="http://hellokoding.com/content/images/2019/06/SlidingWindow_MininumWindowSubstring.png" alt="Minimum Window Substring"><p>Iterating over <code>s</code> window by window with two index pointers <code>i</code> and <code>j</code> to find the minimum substring</p>

<h4 id="implementation">Implementation</h4>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/WindowSliding_GivenString_FindMinSubstr.java">
</code></pre>

<h4 id="complexity">Complexity</h4>

<ul>
<li>Time complexity: O(m+n)</li>
<li>Space complexity: O(m+n)</li>
</ul>]]></content:encoded></item><item><title><![CDATA[Sliding Window Tutorial and Example with The Maximum Subarray Problem]]></title><description><![CDATA[<p>Sliding window is a method for iterating over a linear collection by maintaining a window range indices (group of consecutive elements) to satisfy the problem constraints</p>

<p>Sliding window is an improvement over brute force iteration to reduce the time complexity</p>

<p>Let's see a specific example</p>

<h3 id="themaximumsubarrayproblem">The Maximum Subarray problem</h3>

<p>Given</p>]]></description><link>http://hellokoding.com/window-sliding/</link><guid isPermaLink="false">0179b275-19e6-439e-bcb1-44f4d0f53513</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Fri, 08 Mar 2019 16:33:29 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/SlidingWindow_MaximumSubarray.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/06/SlidingWindow_MaximumSubarray.png" alt="Sliding Window Tutorial and Example with The Maximum Subarray Problem"><p>Sliding window is a method for iterating over a linear collection by maintaining a window range indices (group of consecutive elements) to satisfy the problem constraints</p>

<p>Sliding window is an improvement over brute force iteration to reduce the time complexity</p>

<p>Let's see a specific example</p>

<h3 id="themaximumsubarrayproblem">The Maximum Subarray problem</h3>

<p>Given an array <code>A</code>, write an algorithm to find the maximum sum of <code>k</code> consecutive elements in <code>A</code></p>

<h4 id="approach1bruteforce">Approach 1: Brute force</h4>

<p>Iterating over <code>A</code> one by one element to find max sum</p>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/SubarrayMaxSumBruteforce.java">
</code></pre>

<h4 id="approach2slidingwindow">Approach 2: Sliding Window</h4>

<p>Iterating over <code>A</code> window by window to find max sum</p>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/SubarrayMaxSumWindowSliding.java">
</code></pre>]]></content:encoded></item><item><title><![CDATA[Divide and Conquer Tutorial and Example with Merge Sort]]></title><description><![CDATA[<p>Divide and Conquer is a method for solving a problem by the following steps</p>

<ul>
<li><em>Divide</em> recursively the problem into non overlapping subproblems until these become simple enough to be solved directly</li>
<li><em>Conquer</em> the subproblems by solving them recursively. If they are small enough, solve them as base cases</li>
<li><em>Combine</em> the</li></ul>]]></description><link>http://hellokoding.com/divide-and-conquer/</link><guid isPermaLink="false">b8fa4b72-bb49-421b-a001-27774dba4a52</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Tue, 26 Feb 2019 15:58:37 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/Divide-Conquer_MergeSort.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/06/Divide-Conquer_MergeSort.png" alt="Divide and Conquer Tutorial and Example with Merge Sort"><p>Divide and Conquer is a method for solving a problem by the following steps</p>

<ul>
<li><em>Divide</em> recursively the problem into non overlapping subproblems until these become simple enough to be solved directly</li>
<li><em>Conquer</em> the subproblems by solving them recursively. If they are small enough, solve them as base cases</li>
<li><em>Combine</em> the solution to the subproblems into the solution for the original problem</li>
</ul>

<p>Let's see a specific example</p>

<h3 id="mergesort">Merge Sort</h3>

<p>Merge sort is an efficient sorting algorithm using Divide and Conquer method. </p>

<ul>
<li>It divide the unsorted list into N sublists util each containing one element</li>
<li>Sort/Conquer the sublists by solving them as base cases, a list of one element is considered sorted</li>
<li>Repeatedly merge/combine sublists to produce new sorted sublists util there is only one sublist remaining. This will be the sorted list</li>
</ul>

<h3 id="implementationexample">Implementation example</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/MergeSortTopDown.java">
</code></pre>]]></content:encoded></item><item><title><![CDATA[Given a set, find all subsets]]></title><description><![CDATA[<h3 id="problem">Problem</h3>

<p>Given an array <code>a</code>, find all its subsets</p>

<h3 id="example">Example</h3>

<p>Array <code>[1, 2, 3]</code> will have the following subsets</p>

<pre><code class="language-bash">[]
[1]
[1, 2]
[1, 2, 3]
[1, 3]
[2]
[2, 3]
[3]
</code></pre>

<h3 id="approachbacktracking">Approach: Backtracking</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/BackTracking_FindAllSubsets.java">
</code></pre>]]></description><link>http://hellokoding.com/given-a-set-find-all-subsets/</link><guid isPermaLink="false">d7ec2d62-d24e-43cc-9bcf-0bf01ae52a46</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Thu, 14 Mar 2019 15:41:00 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/Backtracking_AllSubsets.png" medium="image"/><content:encoded><![CDATA[<h3 id="problem">Problem</h3>

<img src="http://hellokoding.com/content/images/2019/06/Backtracking_AllSubsets.png" alt="Given a set, find all subsets"><p>Given an array <code>a</code>, find all its subsets</p>

<h3 id="example">Example</h3>

<p>Array <code>[1, 2, 3]</code> will have the following subsets</p>

<pre><code class="language-bash">[]
[1]
[1, 2]
[1, 2, 3]
[1, 3]
[2]
[2, 3]
[3]
</code></pre>

<h3 id="approachbacktracking">Approach: Backtracking</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/BackTracking_FindAllSubsets.java">
</code></pre>]]></content:encoded></item><item><title><![CDATA[Given a string, find all permutations]]></title><description><![CDATA[<h3 id="problem">Problem</h3>

<p>Given a string, find all permutations of it</p>

<h3 id="example">Example</h3>

<p>The string <code>ABC</code> will have the following permutations</p>

<pre><code class="language-bash">ABC ACB BAC BCA CBA CAB
</code></pre>

<h3 id="approachbacktracking">Approach: Backtracking</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/BackTracking_StringPermutations.java">
</code></pre>]]></description><link>http://hellokoding.com/given-a-string-find-all-permutations/</link><guid isPermaLink="false">ca162287-d92f-4cf7-93f6-51d8dd7049fb</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Fri, 26 Apr 2019 15:54:09 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/Backtracking_StringPermuatations.png" medium="image"/><content:encoded><![CDATA[<h3 id="problem">Problem</h3>

<img src="http://hellokoding.com/content/images/2019/06/Backtracking_StringPermuatations.png" alt="Given a string, find all permutations"><p>Given a string, find all permutations of it</p>

<h3 id="example">Example</h3>

<p>The string <code>ABC</code> will have the following permutations</p>

<pre><code class="language-bash">ABC ACB BAC BCA CBA CAB
</code></pre>

<h3 id="approachbacktracking">Approach: Backtracking</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/BackTracking_StringPermutations.java">
</code></pre>]]></content:encoded></item><item><title><![CDATA[Backtracking Tutorial and Example with The N Queens Problem]]></title><description><![CDATA[<p>In this tutorial, you will learn about Backtracking and its approach to solve constraint satisfaction problems such as crosswords and puzzles</p>

<h3 id="whatisbacktracking">What is Backtracking?</h3>

<p>Backtracking is a method for solving a constraint satisfaction problem by incrementally building candidates to solution and abandoning a candidate as soon as it can not</p>]]></description><link>http://hellokoding.com/backtracking/</link><guid isPermaLink="false">06c1ba94-35e6-4ef2-94a3-1ee0c139a983</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Thu, 28 Feb 2019 15:26:18 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/Backtracking_NQueens.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/06/Backtracking_NQueens.png" alt="Backtracking Tutorial and Example with The N Queens Problem"><p>In this tutorial, you will learn about Backtracking and its approach to solve constraint satisfaction problems such as crosswords and puzzles</p>

<h3 id="whatisbacktracking">What is Backtracking?</h3>

<p>Backtracking is a method for solving a constraint satisfaction problem by incrementally building candidates to solution and abandoning a candidate as soon as it can not satisfy the constraint</p>

<p>Let's see a specific example</p>

<h3 id="thenqueenspuzzle">The N queens puzzle</h3>

<p>Write an algorithm to place N chess queens on an NxN chessboard so that no two queens threaten each other; thus, a solution requires that no two queens share the same row, column or diagonal</p>

<h3 id="backtrackingapproach">Backtracking approach</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/NQueens.java">
</code></pre>

<p><code>int[][] board = new int[8][8]</code> all cells default value are 0</p>

<p><code>isValid(board, row, col)</code> ensures no two queens share the same row, column or diagonal</p>

<p><code>enumerate(board, col)</code> tries all possible candidates starting from column 0 to 7, backtracks to remove the queen from the board as soon as can not build solution</p>

<p><code>col == board.length</code> means all queen are placed on the board</p>

<p><code>board[i][col] = 1</code> places a queen on the board at rows <code>i</code> and column <code>col</code></p>

<p><code>board[i][col] = 0</code> removes the queen at rows <code>i</code> and column <code>col</code> from the board</p>]]></content:encoded></item><item><title><![CDATA[Find subarray with given sum]]></title><description><![CDATA[<h3 id="problem">Problem</h3>

<ul>
<li>Given an unsorted array of non-negative integers <code>A</code> and a number <code>sum</code></li>
<li>Find a continuous subarray that adds up to <code>sum</code></li>
</ul>

<h3 id="approach1bruteforce">Approach 1: Brute Force</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/SubarrayGivenSumBruteforce.java">
</code></pre>

<h3 id="approach2slidingwindow">Approach 2: Sliding Window</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/SubarrayGivenSumWindowSliding.java">
</code></pre>]]></description><link>http://hellokoding.com/find-subarray-with-given-sum/</link><guid isPermaLink="false">bc72f223-8111-46f3-8275-308a861cb5bb</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Sun, 10 Mar 2019 05:17:28 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/ArrayAlgorithms_SubarraywGivenSum.png" medium="image"/><content:encoded><![CDATA[<h3 id="problem">Problem</h3>

<ul>
<li>Given an unsorted array of non-negative integers <code>A</code> and a number <code>sum</code></li>
<li>Find a continuous subarray that adds up to <code>sum</code></li>
</ul>

<h3 id="approach1bruteforce">Approach 1: Brute Force</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/SubarrayGivenSumBruteforce.java">
</code></pre>

<h3 id="approach2slidingwindow">Approach 2: Sliding Window</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/SubarrayGivenSumWindowSliding.java">
</code></pre>]]></content:encoded></item><item><title><![CDATA[Dynamic Programming Tutorial and Example with Fibonacci Numbers]]></title><description><![CDATA[<p>Dynamic Programming is a method for solving a problem by breaking it down into subproblems of the same type with smaller input and storing the computed results of overlapping subproblems to reuse them and save time later</p>

<p>Let's see a specific example</p>

<h3 id="thefibonaccinumbers">The Fibonacci numbers</h3>

<p>The Fibonacci numbers form a</p>]]></description><link>http://hellokoding.com/dynamic-programming/</link><guid isPermaLink="false">511ba780-8068-45fd-afd8-ab841077ed1c</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Tue, 26 Feb 2019 10:49:18 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/DynamicProgramming_FibonacciNumbers.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/06/DynamicProgramming_FibonacciNumbers.png" alt="Dynamic Programming Tutorial and Example with Fibonacci Numbers"><p>Dynamic Programming is a method for solving a problem by breaking it down into subproblems of the same type with smaller input and storing the computed results of overlapping subproblems to reuse them and save time later</p>

<p>Let's see a specific example</p>

<h3 id="thefibonaccinumbers">The Fibonacci numbers</h3>

<p>The Fibonacci numbers form a sequence such that each number is the sum of two preceding ones, starting from 0 and 1</p>

<p>F<sub>0</sub> = 0, F<sub>1</sub> = 1 <br>
F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub> for n > 1</p>

<h3 id="problem">Problem</h3>

<p>Given a number n, write an algorithm to print the value of Fibonacci number F<sub>n</sub></p>

<h3 id="approach1recursion">Approach 1: Recursion</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/FibonacciRecursion.java">
</code></pre>

<h3 id="approach2memoizationtopdowndynamicprogramming">Approach 2: Memoization/Top-down Dynamic Programming</h3>

<p>Using an array to store computed results starting from N to 0, so called top-down</p>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/FibonacciMemoization.java">
</code></pre>

<h3 id="approach3tabulationbottomupdynamicprogramming">Approach 3: Tabulation/Bottom-up Dynamic Programming</h3>

<p>Using an array to store computed results starting from 0 to N, so called bottom-up</p>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/FibonacciTabular.java">
</code></pre>]]></content:encoded></item><item><title><![CDATA[Longest Increasing Subsequence]]></title><description><![CDATA[<p>Longest increasing subsequence is obtained from a sequence, has elements in increasing sorted order and as long as possible. The subsequence does not necessarily have to be contiguous or unique</p>

<p>For example, given the array [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7,</p>]]></description><link>http://hellokoding.com/longest-increasing-subsequence/</link><guid isPermaLink="false">a43199e2-2402-41a0-a29f-af463aa0104f</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Tue, 10 Oct 2017 15:10:49 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/DynamicProgramming_LongestIncreasingSubsequence.png" medium="image"/><content:encoded><![CDATA[<img src="http://hellokoding.com/content/images/2019/06/DynamicProgramming_LongestIncreasingSubsequence.png" alt="Longest Increasing Subsequence"><p>Longest increasing subsequence is obtained from a sequence, has elements in increasing sorted order and as long as possible. The subsequence does not necessarily have to be contiguous or unique</p>

<p>For example, given the array [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15], the longest increasing subsequences is {0, 2, 6, 9, 11, 15}. It's not contiguous or unique. Other instances are {0, 2, 6, 9, 13, 15}, {0, 4, 6, 9, 11, 15, {0, 4, 6, 9, 13, 15}</p>

<h2 id="problem1">Problem 1</h2>

<p>Given an array of numbers, write an algorithm to find the length of the longest increasing subsequence in the array</p>

<h4 id="dynamicprogrammingbottomuptabulationapproach">Dynamic programming bottom-up/tabulation approach</h4>

<p>Using an array to cache computed results</p>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/LISLengthByDPBottomUp.java">
</code></pre>

<p>Time complexity: O(n<sup>2</sup>) <br>
Space complexity: O(n)</p>

<h2 id="problem2">Problem 2</h2>

<p>Given an array of numbers, write an algorithm to find the longest increasing subsequence in the array</p>

<h4 id="dynamicprogrammingbottomuptabulationapproach">Dynamic programming bottom-up/tabulation approach</h4>

<p>Using an array to cache computed results</p>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/LISByDPBottomUp.java">
</code></pre>

<p>Time complexity: O(n<sup>2</sup>) <br>
Space complexity: O(n)</p>

<h2 id="references">References</h2>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence">https://en.wikipedia.org/wiki/Longest_increasing_subsequence</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[0-1 Knapsack Problem]]></title><description><![CDATA[<h3 id="problem">Problem</h3>

<p>Given a set of items, each with a weight and a value. Determine the maximum value of items to include in a collection so that the total weight is less than or equal to a given limit</p>

<h3 id="example">Example</h3>

<p>Given 3 items with weights = {10, 20 , 30} and values = {60,</p>]]></description><link>http://hellokoding.com/0-1-knapsack-problem/</link><guid isPermaLink="false">d26955d8-5005-4e4f-9ccd-1ce7bcb67822</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Tue, 30 Apr 2019 14:55:24 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/DynamicProgramming_0-1Knapsack.png" medium="image"/><content:encoded><![CDATA[<h3 id="problem">Problem</h3>

<img src="http://hellokoding.com/content/images/2019/06/DynamicProgramming_0-1Knapsack.png" alt="0-1 Knapsack Problem"><p>Given a set of items, each with a weight and a value. Determine the maximum value of items to include in a collection so that the total weight is less than or equal to a given limit</p>

<h3 id="example">Example</h3>

<p>Given 3 items with weights = {10, 20 , 30} and values = {60, 100, 120} respectively, knapsack weight capacity is 50. The maximum value of items to include in the knapsack is 220</p>

<h3 id="dynamicprogrammingapproach">Dynamic programming approach</h3>

<p>Have 2 options at each collecting step</p>

<ul>
<li>Including the <code>i</code> item if not exceeding the weight limit</li>
<li>Excluding the <code>i</code> item if exceeding the weight limit</li>
</ul>

<h3 id="implementation">Implementation</h3>

<p>Fill up a cache matrix <code>int[][] cache = new int[N+1][W+1]</code> with</p>

<ul>
<li>0 to <code>N</code> items as columns</li>
<li>0 to <code>W</code> weight-limit as rows</li>
<li>each matrix cell <code>cache[i][w]</code> is the maximum value can be attained with weight less than or equal to <code>w</code> using <code>i</code> items</li>
</ul>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/DP_Knapsack.java">
</code></pre>

<ul>
<li><code>i</code> is the current item</li>
<li><code>w</code> is the current weight limit</li>
<li><code>weights[i-1]</code> is weight of current item as <code>int[] weights</code> is 0 based index</li>
<li><code>values[i-1]</code> is value of current item as <code>int[] values</code> is 0 based index</li>
<li><code>cache[i][w]</code> is maximum value of current item as <code>int[][] cache</code> is 1 based index</li>
<li><code>weights[i-1] &gt; w</code> weight of the current item is more than the weight limit</li>
<li><code>cache[i][w] = cache[i-1][w]</code> excludes the current item</li>
<li><code>cache[i-1][w-weights[i-1]] + values[i-1]</code> includes the current item</li>
</ul>

<h3 id="references">References</h3>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Knapsack_problem">https://en.wikipedia.org/wiki/Knapsack_problem</a></li>
<li><a href="https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/">https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Unique Paths Without Obstacles]]></title><description><![CDATA[<h3 id="problem">Problem</h3>

<p>Given a 2D array A[M][N], aka Grid / Maze / Matrix</p>

<p>Write an algorithm to count the number of unique paths to reach to A[M-1][N-1] from A[0][0]</p>

<p>At any cell (x, y), you can either go to (x+1, y) or (x, y+1)</p>

<h3 id="example">Example</h3>]]></description><link>http://hellokoding.com/count-unique-paths-in-a-grid-maze-matrix/</link><guid isPermaLink="false">a6f8e2e2-1551-4dbe-9d0e-1f8c9379e5bb</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Fri, 15 Mar 2019 15:18:27 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/DynamicProgramming_UniquePaths-1.png" medium="image"/><content:encoded><![CDATA[<h3 id="problem">Problem</h3>

<img src="http://hellokoding.com/content/images/2019/06/DynamicProgramming_UniquePaths-1.png" alt="Unique Paths Without Obstacles"><p>Given a 2D array A[M][N], aka Grid / Maze / Matrix</p>

<p>Write an algorithm to count the number of unique paths to reach to A[M-1][N-1] from A[0][0]</p>

<p>At any cell (x, y), you can either go to (x+1, y) or (x, y+1)</p>

<h3 id="example">Example</h3>

<p>Input <code>A[3][3]</code> with values <code>{{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}</code></p>

<p>Expected output <code>6</code></p>

<h3 id="approach">Approach</h3>

<p>Using dynamic programming bottom-up</p>

<ul>
<li>Fill up matrix <code>cache[i][j]</code> to count unique paths to <code>(i,j)</code></li>
<li><code>cache[i][j] = cache[i-1][j] + cache[i][j-1]</code> for each <code>(i,j)</code></li>
<li><code>cache[i][0]</code> and <code>cache[0][j]</code> are base cases </li>
<li><code>cache[rows-1][cols-1]</code> is final result</li>
</ul>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/DP_UniquePaths_WithOutObstacles.java">
</code></pre>]]></content:encoded></item><item><title><![CDATA[Unique Paths With Obstacles]]></title><description><![CDATA[<h3 id="problem">Problem</h3>

<p>Given a 2D array A[M][N], aka Grid / Maze / Matrix</p>

<p>Write an algorithm to count the number of unique paths to reach to A[M-1][N-1] from A[0][0]</p>

<p>At any cell (x, y), you can either go to (x+1, y) or (x, y+1) if</p>]]></description><link>http://hellokoding.com/count-unique-paths-in-a-2d-array-grid-maze-matrix-with-obstacles/</link><guid isPermaLink="false">24cfd478-1e4c-4055-be30-c2dac2520e9e</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Fri, 15 Mar 2019 15:34:15 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/DynamicProgramming_UniquePaths.png" medium="image"/><content:encoded><![CDATA[<h3 id="problem">Problem</h3>

<img src="http://hellokoding.com/content/images/2019/06/DynamicProgramming_UniquePaths.png" alt="Unique Paths With Obstacles"><p>Given a 2D array A[M][N], aka Grid / Maze / Matrix</p>

<p>Write an algorithm to count the number of unique paths to reach to A[M-1][N-1] from A[0][0]</p>

<p>At any cell (x, y), you can either go to (x+1, y) or (x, y+1) if there's no obstacle</p>

<h3 id="example">Example</h3>

<p>Input <code>A[3][3]</code> with values <code>{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}}</code>, 0 and 1 represent for empty and obstacle respectively</p>

<p>Expected output <code>2</code></p>

<h3 id="approach">Approach</h3>

<p>Using dynamic programming bottom-up</p>

<ul>
<li>Fill up matrix <code>cache[i][j]</code> to count unique paths to <code>(i,j)</code></li>
<li><code>cache[i][j] = cache[i-1][j] + cache[i][j-1]</code> for each <code>(i,j)</code> with <code>A[i][j]</code> as 0</li>
<li><code>cache[0][0] = 1</code>, <code>cache[i][0]</code> and <code>cache[0][j]</code> are base cases </li>
<li><code>cache[rows-1][cols-1]</code> is final result</li>
</ul>

<h3 id="implementation">Implementation</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/DP_UniquePaths_Obstacles.java">
</code></pre>]]></content:encoded></item><item><title><![CDATA[Box Stacking Problem]]></title><description><![CDATA[<h3 id="problem">Problem</h3>

<p>Given a set of rectangular 3D boxes, each with height, width and depth. Find the maximum height of the stack created from them</p>

<ul>
<li>The lower box must have area larger than the higher box</li>
<li>A box can be rotated to any side</li>
<li>Can use multiple instances of the same</li></ul>]]></description><link>http://hellokoding.com/box-stacking-problem/</link><guid isPermaLink="false">e1174a8d-3570-4a69-842c-f419d568b01c</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Wed, 01 May 2019 16:07:09 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/DynamicProgramming_BoxStacking.png" medium="image"/><content:encoded><![CDATA[<h3 id="problem">Problem</h3>

<img src="http://hellokoding.com/content/images/2019/06/DynamicProgramming_BoxStacking.png" alt="Box Stacking Problem"><p>Given a set of rectangular 3D boxes, each with height, width and depth. Find the maximum height of the stack created from them</p>

<ul>
<li>The lower box must have area larger than the higher box</li>
<li>A box can be rotated to any side</li>
<li>Can use multiple instances of the same box</li>
</ul>

<h3 id="dynamicprogrammingapproach">Dynamic programming approach</h3>

<ul>
<li><p>Max height of stack at <code>i</code> = max height of stack at <code>j</code> + height of box <code>i</code> with <code>i &gt; j</code></p></li>
<li><p>Each box has 3 instances to try as it can be rotated to any side</p></li>
</ul>

<h3 id="implementation">Implementation</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/DP_BoxStacking.java">
</code></pre>

<h3 id="references">References</h3>

<ul>
<li><a href="https://www.geeksforgeeks.org/box-stacking-problem-dp-22/">https://www.geeksforgeeks.org/box-stacking-problem-dp-22/</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[3Sum Problem]]></title><description><![CDATA[<h3 id="problem">Problem</h3>

<p>Given an array of integers <code>A[N]</code> and an integer number <code>targetSum</code></p>

<p>Find if existing in <code>A</code> three integers <code>A[i]</code>, <code>A[j]</code> and <code>A[k]</code> such that <code>A[i] + A[j] + A[k] = targetSum</code></p>

<h3 id="example">Example</h3>

<p>Input <code>A[8] = {4, -9, 0, 11, 6, -20, 1, 7}</code>, <code>targetSum = 10</code></p>]]></description><link>http://hellokoding.com/the-3sum-problem/</link><guid isPermaLink="false">a8ba8e58-66c3-4ea6-bd02-6e8ccbde401b</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[Giau Ngo]]></dc:creator><pubDate>Sat, 16 Mar 2019 07:47:48 GMT</pubDate><media:content url="http://hellokoding.com/content/images/2019/06/TwoPointers_3Sum.png" medium="image"/><content:encoded><![CDATA[<h3 id="problem">Problem</h3>

<img src="http://hellokoding.com/content/images/2019/06/TwoPointers_3Sum.png" alt="3Sum Problem"><p>Given an array of integers <code>A[N]</code> and an integer number <code>targetSum</code></p>

<p>Find if existing in <code>A</code> three integers <code>A[i]</code>, <code>A[j]</code> and <code>A[k]</code> such that <code>A[i] + A[j] + A[k] = targetSum</code></p>

<h3 id="example">Example</h3>

<p>Input <code>A[8] = {4, -9, 0, 11, 6, -20, 1, 7}</code>, <code>targetSum = 10</code></p>

<p>Expected output <code>true</code></p>

<h3 id="twopointersapproach">Two pointers approach</h3>

<pre><code class="language-java embedfile-https://github.com/hellokoding/hellokoding-courses/blob/master/datastructure-algorithm-java-examples/src/main/java/com/hellokoding/algorithm/TwoPointers_3Sum.java">
</code></pre>]]></content:encoded></item></channel></rss>